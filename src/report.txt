This file will track what we have implemented thus far

Terminals:
	Recieve is done
	Transmit is done

Trap:
	Kernel
	Clock {It says that its round robin but we will check more}
	Illegal
	Memory
	Math
	Receive
	Transmit
	Abort {Logic mostly fixed}

Syscalls:
	Checked all major syscall and I/O
	Need to verify pipes, cvar, anc lock




Test:
	Math.c:
		Simple file to abort a child with a math trap. 
		The child always prints first
		It aborts and does not print it second message
		The parent reaps its value correctly
		The parent exits 40
		Status: Passed :)

	getpid_test.c:
		Simple test for GetPid, TtyWrite, and Exit
		Returns pid 1
		Writes it out to terminal 0
		Exits with 0
		Status: Passed :)

	getpid.c:
		Simple file to test GetPid and Exit
		Returns pid 1 {Since there is no Fork}
		Exits with 100
		Status: Passed :)

	torture.c:
		Lots of fun
		Bunch of random stuff happening the terminal
		Does not crash though :)
		Status: Passed :) {If not crashing means passed}

	forky.c:
		Fork testfile
		Parent or child can print a message first to terminal 0
		Parent gets trapped in Wait
		Child writes out its status {0} and pid {2}
		Child exits with 45
		Parent writes out its status {45} and pid {1} (45 since it reaps it from the child)
		Parent exits with 45
		Status: Passed :)
	wait.c:
		Spawn in one child process
		Write to terminal 0
		Exit 10
		Parent wakes up and writes to terminal 0
		Parent is back on wait
		Spawn in another child process
		Write to terminal 0
		Exit 20
		Parent wakes up and writes to terminal 0
		Parent exits
		Status: Passed :)

	tty_test.c:
		Fork a process
		Parent or child writes to terminal first
		Parent stuck in Wait
		Child waits for input to be read from terminal 0
		Child reads input and then leaves
		Child exits with 43
		Parent wakes up
		Parent Writes to terminal
		It does not get stuff in a infinite loop 
		parent waits to read input from terminal 0
		exits with 43
		Status: Passed :)
	
	read_test.c:
		This test is to test my string concatenation logic}
		Write to terminal 2
		Delay so that user can input into terminal 1
		I type in many messages and return for each message
		I read from terminal 1
		I then print the message i got into terminal 0 
		Exit with 70
		Status: Passed :)
	zero.c:
		Memory Trap occurs
		Process Aborted
		Status: Passed :) {I think}

	terminal_test.c:
		Simple test to test TtyWrite and TtyRead
		Write to terminal 0 and 3 
		Read from the terminal 3
		Write the input from terminal 3 into terminal 0
		Exit with 67
		Status: Passed :)

	lock.c:
                Tests LockInit, Acquire, Release, Delay, and Fork.
                Parent initializes lock 0 and acquires it.
                Child tries to acquire lock 0 and correctly blocks.
                Parent delays, then releases lock 0.
                The child wakes up, acquires lock 0, and prints confirmation.
                Both processes exit normally with no deadlocks or unexpected behavior.
                status: passed :)

        cvar.c:
                Cvar test file tests CvarInit, LockInit, Acquire, CvarWait, CvarSignal, and Delay.
                Parent initializes a lock and a cvar, acquires the lock, then calls CvarWait.
                The parent correctly releases the lock when waiting and blocks.
                Child delays for a few ticks, then signals the cvar.
                The parent wakes up, re-acquires the lock, and continues running.
                Parent exits with the expected status (67).
                status: passed :)

	brk_test2.c:
		Brk test
		We call brk with two valid inputs
		We then call brk with two invalid inputs
		We print the returns values at the end using a TtyPrintf to terminal 0
		We expect the output to be 0, 0, Error, Error
		The output at the end was: 0>[Brk Test] normal1=0, normal2=0, too_low=-1, too_high=-1
		Exit with 30
		Status: Passed :)
	
	bigstack.c:
		Bigstack test
		The user attempts to right into the current heap space
		Our Kernel detects this and aborts the current process
		Status: Passed :)

	exec_test.c:
		File for exec testing
		This files execs another file
		it execs brk correctly
		It loads the content and display data to the terminal
		Exits with 30
		Status: Passed :)

	forkstack.c:
		Recurses until 27 for both child and parent
		Status: IDK

	simple_read.c:
		A simple read test
		Read from terminal 1
		Store in buffer and write out the terminal 
		Exit 98
		Status: Passed :)

	tty_read.c:
		Another simple read test
		read ten bytes from terminal 0
		Exit 0 
		Status: Passed :)
	write.c:
		Simple write test
		Print my message to terminal 3
		Exit with 56
		Status: Passed :)

	write2.c:
		Simple write test
		Print or write a huge buffer to terminal 3
		Exit with 56
		Status: Passed :)

	brk_test:
                brk_test file tests brk by calling it to insert two brks, one at
                0x120000 and another at 0x140000. Brk evaluates the new addresses
                and verifies them as safe, it then grows the heap
                Brk(0x120000) grows the heap from VPN 4 --> 15 allocating 12 pages
                Brk(0x140000) grows the heap from VPN 16 --> 31 allocating 16 pages
                Brk correctly rounds the addresses and checks stack bounds,
                allocates and updates the brk.
                status: Passed :)

	delay_test:
                pid 1 calls delay and has it wait for 3 ticks
                Pid 1 calls delay(3) and is blocked until tick 5
                idle proc runs ticks 2-5
                tick 5 lcok trap wakes pid 1
                pid 1 os unblocked
                exits returns 0
                status: Passed :)

	syscall_test:
                tests Getpid, Brk, Delay, Tyywrite
                Get pid is called and returns 1
                Brk is called twice once at 0x110000 and agian at 0x130000
                at 0x110000 heap grows from vpn 4 --> 7 retruns 0
                at 0x130000 heap grows from vpn 24 --> 31 returns 0
                calls delay in a loop 5 times, PID 1 blocked until tick 7
                clock trap wake PID correctly
                exit is called, and machines halts

	pipe_r2w.c:
		GetPid is called and returns 1
		Pipe 0 is created
		Fork is called
		Parent is delayed 
		reader function is called
		Child should be blocked
		Fork is called again 
		reader function is called
		Parents is free from delay
		Parent forks twice
		Function writer is called twice
		Parent is delayed
		Readers should read input from writers
		Parent is freed from delay
		exit with 0
		Status: Status Passed :)
	pipe_w2r.c:
		GetPid is called and returns 1
		Pipe 0 is created
		Fork is called twice
		Parent is delayed
		write function is called twice
		parent wakes up from delay
		parent forks twice
		parent is delayed
		children read from pipe
		children delayed
		parent wakes up from delay and exits with 0
		The input is written and read in a fifo manner
		Status: Passed :)



	
	


	

	
		




	
	


